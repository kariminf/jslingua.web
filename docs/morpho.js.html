

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Source: morpho.js | JsLingua doc</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/bootstrap.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-jsdoc.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/tui-doc.css">

    
</head>
<body>
<nav class="lnb" id="lnb">
    <div class="logo" style="width: 50px; height: 50px">
        
            <a href="https://kariminf.github.io/jslingua.web/" rel="noopener noreferrer" target="_blank">
                <img src="logo.png" width="100%" height="100%">
            </a>
        
    </div>
    <div class="title">
        <h1><a href="index.html" class="link">JsLingua doc</a></h1>
        
    </div>
    <div class="search-container" id="search-container">
        <input type="text" placeholder="Search">
        <ul></ul>
    </div>
    
    <div class="lnb-api hidden"><h3>Modules</h3><ul><li><a href="module-JsLingua.html">JsLingua</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="module:JsLingua_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="module-JsLingua.html#.aserv">aserv</a></li><li><a href="module-JsLingua.html#.gdir">gdir</a></li><li><a href="module-JsLingua.html#.getDir">getDir</a></li><li><a href="module-JsLingua.html#.getService">getService</a></li><li><a href="module-JsLingua.html#.getVersion">getVersion</a></li><li><a href="module-JsLingua.html#.gserv">gserv</a></li><li><a href="module-JsLingua.html#.gversion">gversion</a></li><li><a href="module-JsLingua.html#.llang">llang</a></li><li><a href="module-JsLingua.html#.nserv">nserv</a></li><li><a href="module-JsLingua.html#.serviceLanguages">serviceLanguages</a></li></ul></div></li><li><a href="module-Tools.html">Tools</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="module:Tools_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="module-Tools.html#.htmlEntities">htmlEntities</a></li><li><a href="module-Tools.html#.readMorse">readMorse</a></li></ul></div></li></ul></div><div class="lnb-api hidden"><h3>Classes</h3><ul><li><a href="AraInfo.html">AraInfo</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="AraInfo_sub"></div></li><li><a href="AraLang.html">AraLang</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="AraLang_sub"></div></li><li><a href="AraMorpho.html">AraMorpho</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="AraMorpho_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="AraMorpho.html#.norm">norm</a></li></ul></div></li><li><a href="AraTrans.html">AraTrans</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="AraTrans_sub"></div></li><li><a href="EngInfo.html">EngInfo</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="EngInfo_sub"></div></li><li><a href="EngLang.html">EngLang</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="EngLang_sub"></div></li><li><a href="EngMorpho.html">EngMorpho</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="EngMorpho_sub"></div></li><li><a href="EngTrans.html">EngTrans</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="EngTrans_sub"></div></li><li><a href="FraInfo.html">FraInfo</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="FraInfo_sub"></div></li><li><a href="FraLang.html">FraLang</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="FraLang_sub"></div></li><li><a href="FraMorpho.html">FraMorpho</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="FraMorpho_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="FraMorpho.html#.jconjmod">jconjmod</a></li></ul></div></li><li><a href="FraTrans.html">FraTrans</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="FraTrans_sub"></div></li><li><a href="Info.html">Info</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="Info_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="Info.html#.getBranch">getBranch</a></li><li><a href="Info.html#.getCode">getCode</a></li><li><a href="Info.html#.getDir">getDir</a></li><li><a href="Info.html#.getFamily">getFamily</a></li><li><a href="Info.html#.getName">getName</a></li><li><a href="Info.html#.getOrigName">getOrigName</a></li><li><a href="Info.html#.getWordOrder">getWordOrder</a></li></ul></div></li><li><a href="JpnInfo.html">JpnInfo</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="JpnInfo_sub"></div></li><li><a href="JpnLang.html">JpnLang</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="JpnLang_sub"></div></li><li><a href="JpnMorpho.html">JpnMorpho</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="JpnMorpho_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="JpnMorpho.html#.normalize">normalize</a></li></ul></div></li><li><a href="JpnTrans.html">JpnTrans</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="JpnTrans_sub"></div></li><li><a href="Lang.html">Lang</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="Lang_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="Lang.html#._nChs">_nChs</a></li><li><a href="Lang.html#._nTrans">_nTrans</a></li><li><a href="Lang.html#.all">all</a></li><li><a href="Lang.html#.allCharSetFunction">allCharSetFunction</a></li><li><a href="Lang.html#.availableCharSets">availableCharSets</a></li><li><a href="Lang.html#.availableTransformations">availableTransformations</a></li><li><a href="Lang.html#.contains">contains</a></li><li><a href="Lang.html#.containsCharSetFunction">containsCharSetFunction</a></li><li><a href="Lang.html#.lchars">lchars</a></li><li><a href="Lang.html#.ltrans">ltrans</a></li><li><a href="Lang.html#.nbr2str">nbr2str</a></li><li><a href="Lang.html#.pronounceNumber">pronounceNumber</a></li><li><a href="Lang.html#.trans">trans</a></li><li><a href="Lang.html#.transformationFunction">transformationFunction</a></li><li><a href="Lang.html#.verifyCharSetFunction">verifyCharSetFunction</a></li></ul></div></li><li><a href="Morpho.html">Morpho</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="Morpho_sub"><div class="member-type">Members</div><ul class="inner"><li><a href="Morpho.html#.Feature">Feature</a></li></ul><div class="member-type">Methods</div><ul class="inner"><li><a href="Morpho.html#._gNegName">_gNegName</a></li><li><a href="Morpho.html#._gNegOpts">_gNegOpts</a></li><li><a href="Morpho.html#._gPpName">_gPpName</a></li><li><a href="Morpho.html#._gPpOpts">_gPpOpts</a></li><li><a href="Morpho.html#._gVoiceName">_gVoiceName</a></li><li><a href="Morpho.html#._gVoiceOpts">_gVoiceOpts</a></li><li><a href="Morpho.html#._nConv">_nConv</a></li><li><a href="Morpho.html#._nStem">_nStem</a></li><li><a href="Morpho.html#.availablePosConverters">availablePosConverters</a></li><li><a href="Morpho.html#.availableStemmers">availableStemmers</a></li><li><a href="Morpho.html#.conj">conj</a></li><li><a href="Morpho.html#.conjugate">conjugate</a></li><li><a href="Morpho.html#.conv">conv</a></li><li><a href="Morpho.html#.convertPoS">convertPoS</a></li><li><a href="Morpho.html#.disableDebug">disableDebug</a></li><li><a href="Morpho.html#.enableDebug">enableDebug</a></li><li><a href="Morpho.html#.gconjmod">gconjmod</a></li><li><a href="Morpho.html#.getConjugModel">getConjugModel</a></li><li><a href="Morpho.html#.getForms">getForms</a></li><li><a href="Morpho.html#.getOptLists">getOptLists</a></li><li><a href="Morpho.html#.getOptName">getOptName</a></li><li><a href="Morpho.html#.getTenseName">getTenseName</a></li><li><a href="Morpho.html#.getVerbType">getVerbType</a></li><li><a href="Morpho.html#.getVerbType">getVerbType</a></li><li><a href="Morpho.html#.getVerbTypes">getVerbTypes</a></li><li><a href="Morpho.html#.gform">gform</a></li><li><a href="Morpho.html#.goptname">goptname</a></li><li><a href="Morpho.html#.gtensename">gtensename</a></li><li><a href="Morpho.html#.gverbtype">gverbtype</a></li><li><a href="Morpho.html#.lconv">lconv</a></li><li><a href="Morpho.html#.lopt">lopt</a></li><li><a href="Morpho.html#.lstem">lstem</a></li><li><a href="Morpho.html#.norm">norm</a></li><li><a href="Morpho.html#.normalize">normalize</a></li><li><a href="Morpho.html#.parseConjModel">parseConjModel</a></li><li><a href="Morpho.html#.sconv">sconv</a></li><li><a href="Morpho.html#.setCurrentPosConverter">setCurrentPosConverter</a></li><li><a href="Morpho.html#.setCurrentStemmer">setCurrentStemmer</a></li><li><a href="Morpho.html#.sstem">sstem</a></li><li><a href="Morpho.html#.stem">stem</a></li></ul></div></li><li><a href="Trans.html">Trans</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="Trans_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="Trans.html#._nTrans">_nTrans</a></li><li><a href="Trans.html#._sTransCond">_sTransCond</a></li><li><a href="Trans.html#._sUntransCnd">_sUntransCnd</a></li><li><a href="Trans.html#.availableMethods">availableMethods</a></li><li><a href="Trans.html#.l">l</a></li><li><a href="Trans.html#.Me.untransliterate">Me.untransliterate</a></li><li><a href="Trans.html#.s">s</a></li><li><a href="Trans.html#.setCurrentMethod">setCurrentMethod</a></li><li><a href="Trans.html#.sTrans">sTrans</a></li><li><a href="Trans.html#.trans">trans</a></li><li><a href="Trans.html#.transliterate">transliterate</a></li><li><a href="Trans.html#.untrans">untrans</a></li></ul></div></li></ul></div><div class="lnb-api hidden"><h3><a href="global.html">Global</a></h3></div>
</nav>
<div id="resizer"></div>

<div class="main" id="main">
    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>(function () {

  "use strict";

  //==========================================
  // EXPORTING MODULE
  //==========================================

  if ( typeof module === "object" &amp;&amp; module &amp;&amp; typeof module.exports === "object" ) {
    module.exports = Morpho;
  }
  else {
    window.JsLingua.Cls.Morpho = Morpho;
  }

  //==========================================
  // CONSTANTS
  //==========================================

  /**
  * The tense: Past, Present, Future
  * &lt;br>access: Morpho.Feature.Tense
  * @attribute Tense
  * @readOnly
  * @private
  * @static
  * @memberof Morpho
  * @enum {String}
  */
  const Tense = {
    /** past */
    Pa: "past",
    /** present */
    Pr: "present",
    /** future */
    Fu: "future"
  },

  /**
  * The aspect: Simple, Continuous, Perfect, PerfectContinuous
  * &lt;br>access: Morpho.Feature.Aspect
  * @attribute Aspect
  * @readOnly
  * @private
  * @static
  * @memberof Morpho
  * @enum {String}
  */
  Aspect = {
    /** simple */
    S: "simple",
    /** continuous */
    C: "continuous",
    /** perfect */
    P: "perfect",
    /** perfect-continuous */
    PC: "perfect-continuous",
    /** imperfect */
    I: "imperfect"
  },

  /**
  * The mood: indicative, subjunctive, conditional,
  * optative, imperative, jussive, potential,
  * hypothetical, inferential
  * &lt;br>access: Morpho.Feature.Mood
  * @see http://universaldependencies.org/u/feat/Mood.html
  *
  * @attribute Mood
  * @readOnly
  * @private
  * @static
  * @memberof Morpho
  * @enum {String}
  */
  Mood = {
    /**
     * indicative: The indicative can be considered the default mood.
     * A verb in indicative merely states that something happens,
     * has happened or will happen, without adding any attitude of the speaker.
     * @example You study at the university
     */
    Ind: "indicative",

    /**
     * imperative: The speaker uses imperative to order or ask the addressee to do the action of the verb.
     * @example Study at the university
     */
    Imp: "imperative",

    /**
     * conditional: The conditional mood is used to express actions that would have taken
     * place under some circumstances but they actually did not / do not happen.
     * Grammars of some languages may classify conditional as tense (rather than mood)
     * but e.g. in Czech it combines with two different tenses (past and present).
     * @example if she went home
     */
    Cnd: "conditional",

    /**
     * potential: The action of the verb is possible but not certain.
     * This mood corresponds to the modal verbs can, might, be able to. Used e.g. in Finnish.
     * @example she can go home
     */
    Pot: "potential",

    /**
     * subjunctive: The subjunctive mood is used under certain circumstances in subordinate clauses,
     * typically for actions that are subjective or otherwise uncertain.
     * In German, it may be also used to convey the conditional meaning.
     * @example "Je veux que tu le fasses": I want that you to do it
     */
    Sub: "subjunctive",

    /**
     * jussive: The jussive mood expresses the desire that the action happens;
     * it is thus close to both imperative and optative.
     * Unlike in desiderative, it is the speaker, not the subject who wishes that it happens.
     * Used e.g. in Arabic.
     * @example فليكن let it be
     */
    Jus: "jussive",

    /**
     * purposive: Means “in order to”, occurs in Amazonian languages.
     */
    Prp: "purposive",

    /**
     * quotative: The quotative mood is used e.g. in Estonian to denote direct speech.
     */
    Qot: "quotative",

    /**
     * optative: Expresses exclamations like “May you have a long life!” or
     * “If only I were rich!” In Turkish it also expresses suggestions.
     * @example let’s go home
     */
    Opt: "optative",

    /**
     * desiderative: The desiderative mood corresponds to the modal verb “want to”:
     * “He wants to come.” Used e.g. in Turkish.
     */
    Des: "desiderative",

    /**
     * necessitative: The necessitative mood expresses necessity and corresponds to the modal
     * verbs “must, should, have to”: “He must come.”
     */
    Nec: "necessitative",

    /**
     * admirative: Expresses surprise, irony or doubt. Occurs in Albanian,
     * other Balkan languages, and in Caddo (Native American from Oklahoma).
     */
    Adm: "admirative"

  },

  /**
  * The voice: Active,Passive, Middle
  * &lt;br>access: Morpho.Feature.Voice
  * @attribute Voice
  * @readOnly
  * @private
  * @static
  * @memberof Morpho
  * @enum {String}
  */
  Voice = {
    /** active */
    A: "active",
    /** passive */
    P: "passive",
    /** middle */
    M: "middle"
  },

  /**
  * The grammatical number: Singular, Dual, Plural
  * &lt;br>access: Morpho.Feature.Number
  * @attribute GNumber
  * @readOnly
  * @private
  * @static
  * @memberof Morpho
  * @enum {String}
  */
  GNumber = {
    /** singular */
    S: "singular",
    /** dual */
    D: "dual",
    /** plural */
    P: "plural"
  },

  /**
  * The person: First, Second, Third.
  * &lt;br>access: Morpho.Feature.Person
  * @attribute Person
  * @readOnly
  * @private
  * @static
  * @memberof Morpho
  * @enum {String}
  */
  Person = {
    /** first */
    F: "first",
    /** second */
    S: "second",
    /** third */
    T: "third"
  },

  /**
  * The gender: Masculine, Feminine, Neuter.
  * &lt;br>access: Morpho.Feature.Gender
  * @attribute Gender
  * @readOnly
  * @private
  * @static
  * @memberof Morpho
  * @enum {String}
  */
  Gender = {
    /** masculine */
    M: "masculine",
    /** feminine */
    F: "feminine",
    /** neuter */
    N: "neuter"
  };

  /**
  * This is a map to different morphology features:
  * &lt;ul>
  * &lt;li>POS: It returns {@link Morpho.PoS}&lt;/li>
  * &lt;li>Tense: It returns {@link Morpho.Tense}&lt;/li>
  * &lt;li>Aspect: It returns {@link Morpho.Aspect}&lt;/li>
  * &lt;li>Mood: It returns {@link Morpho.Mood}&lt;/li>
  * &lt;li>Voice: It returns {@link Morpho.Voice}&lt;/li>
  * &lt;li>Number: It returns {@link Morpho.GNumber}&lt;/li>
  * &lt;li>Person: It returns {@link Morpho.Person}&lt;/li>
  * &lt;li>Gender: It returns {@link Morpho.Gender}&lt;/li>
  * &lt;/ul>
  * We can access these features either by:&lt;br>
  * Morpho.Feature.feature_name &lt;br>
  * Or: &lt;br>
  * Morpho.Feature["feature_name"]
  *
  * @attribute Feature
  * @readOnly
  * @public
  * @static
  * @memberof Morpho
  * @type {Object}
  */
  Morpho.Feature = {
    //POS: PoS,
    Tense: Tense,
    Aspect: Aspect,
    Mood: Mood,
    Voice: Voice,
    Number: GNumber,
    Person: Person,
    Gender: Gender
  };

  {//Freezing all constants so their values won't be modified
    let C = Object.freeze;
    C(Tense);
    C(Aspect);
    C(Mood);
    C(Voice);
    C(GNumber);
    C(Person);
    C(Gender);
    C(Morpho.Feature);
  }

  //==========================================
  // CLASS CONSTRUCTOR
  //==========================================

  /**
  * Morphology of a specified language
  *
  * @class Morpho
  * @param {String} langCode Language ISO693-2 code: ara, jpn, eng, etc.
  */
  function Morpho(langCode) {

    this.code = langCode;
    //Contains stemmers
    this.stemmers = {};
    this.cstemmer = "";//current stemmer
    //Contains PoS conversions
    this.converters = {};
    this.cconverter = "";//current converter
    this.g = {
      debugFunction: dummyDebug
    };

    let conjList = [];
    let convList = [];
    let stemList = [];
    let conjOpt = {};

    this.s = {
      clear: () => {
        conjList = [];
        convList = [];
        stemList = [];
        conjOpt = {};
        return this.s;
      },

      //Setters

      sconv: convName => {
        this.sconv(convName);
        return this.s;
      },

      sstem: stemName => {
        this.sstem(stemName);
        return this.s;
      },

      //Storers

      conj: (verb, opt) => {
        let opt2 = opt || conjOpt;
        conjOpt = opt2;
        conjList.push(this.conj(verb, opt2));
        return this.s;
      },

			stem: word => {
        stemList.push(this.stem(word));
        return this.s;
      },

      conv: word => {
        convList.push(this.conv(word));
        return this.s;
      },

      //List getters

      lconj: () => {
        return conjList;
      },

      lconv: () => {
        return convList;
      },

      lstem: () => {
        return stemList;
      }

    };

  }

  let Me = Morpho.prototype;

  //==========================================
  // STATIC FUNCTIONS
  //==========================================

  /**
  * Add new stemmer method
  * @method _nStem
  * @protected
  * @memberof Morpho
  * @param  {String} stemmerName the name of the stemmer
  * @param  {String} stemmerDesc   the description of the stemmer
  * @param  {Function} stemmerFct   the function stem(word)
  */
  Morpho._nStem = function (stemmerName, stemmerDesc, stemmerFct) {
    if (typeof stemmerName === "string" &amp;&amp; stemmerName.length > 0){
      let stem = this.stemmers[stemmerName] = {};
      stem.desc = stemmerDesc;
      stem.fct = stemmerFct;
    }
  };

  /**
  * Add new part of speach converter method
  * @method _nConv
  * @protected
  * @memberof Morpho
  * @param  {String} converterName the name of the converter
  * @param  {String} converterDesc   the description of the converter
  * @param  {Function} converterFct   the function convert(word)
  */
  Morpho._nConv = function (converterName, converterDesc, converterFct) {
    if (typeof converterName === "string" &amp;&amp; converterName.length > 0){
      let conv = this.converters[converterName] = {};
      conv.desc = converterDesc;
      conv.fct = converterFct;
    }
  };

  //==========================================
  // DEBUGGING FUNCTIONS
  //==========================================

  /**
  * Enables the debugging messages
  *
  * @method enableDebug
  * @public
  * @memberof Morpho
  */
  Me.enableDebug = function(){
    this.g.debugFunction = realDebug;
  };

  /**
  * disables the debugging messages
  * @method disableDebug
  * @public
  * @memberof Morpho
  */
  Me.disableDebug = function(){
    this.g.debugFunction = dummyDebug;
  };

  //==========================================
  // STEMMING FUNCTIONS
  //==========================================

  /**
  * Stem a word: delete prefixes, suffixes and infixes
  *
  * @method stem
  * @public
  * @final
  * @memberof Morpho
  * @param  {String} word the word to be stemmed
  * @return {String}      stemmed word
  */
  Me.stem = function(word){
    var stemmer = this.stemmers[this.cstemmer];
    if (typeof stemmer !== "object") return word;
    if (typeof stemmer.fct !== "function") return word;
    return stemmer.fct(word);
  };

  /**
  * Returns the list of available stemming methods
  * @method lstem
  * @public
  * @final
  * @memberof Morpho
  * @return {String[]}  Array of Strings containing stemmers names
  */
  Me.lstem = function(){
    return Object.keys(this.stemmers);
  };

  /**
  * Sets the current stemmer
  *
  * @method sstem
  * @public
  * @final
  * @memberof Morpho
  * @param {String} StemmerName stemmer method's name
  */
  Me.sstem = function (StemmerName) {
    if (StemmerName in this.stemmers){
      this.cstemmer = StemmerName;
    }
  };

  Me.gstemdesc = function (stemmerName) {
    if (stemmerName in this.stemmers){
      return this.stemmers[stemmerName].desc;
    }
    return "";
  };


  //==========================================
  // CONVERTION FUNCTIONS
  //==========================================

  /**
  * Convert a word: singular to plural; verb to noun; etc
  *
  * @method conv
  * @public
  * @final
  * @memberof Morpho
  * @param  {String} word the word to be converted
  * @return {String}      converted word
  */
  Me.conv = function(word){
    var converter = this.converters[this.cconverter];
    if (typeof converter !== "object") return word;
    if (typeof converter.fct !== "function") return word;
    return converter.fct(word);
  };

  /**
  * Returns the list of available converting methods
  * @method lconv
  * @public
  * @final
  * @memberof Morpho
  * @return {String[]}  Array of Strings containing converters names
  */
  Me.lconv = function(){
    return Object.keys(this.converters);
  };

  /**
  * Sets the current PoS converter
  *
  * @method sconv
  * @public
  * @final
  * @memberof Morpho
  * @param {String} converterName converter method's name
  */
  Me.sconv = function (converterName) {
    if (converterName in this.converters){
      this.cconverter = converterName;
    }
  };

  Me.gconvdesc = function (converterName) {
    if (converterName in this.converters){
      return this.converters[converterName].desc;
    }
    return "";
  };

  //==========================================
  // CONJUGATION FUNCTIONS
  //==========================================

  /**
  * This function is used for verb conjugation
  *
  * @method conj
  * @public
  * @memberof Morpho
  * @param  {String} verb the word to be conjugated
  * @param  {Object} opts  options for tense, case, voice, aspect, person, number, gender, mood, and other
  * @return {String}      Conjugated verb
  */
  Me.conj = function(verb, _opts){
    return verb;
  };

  //==========================================
  // CONJUGATION OPTIONS PUBLIC FUNCTIONS
  //==========================================

  /**
  * This method is used to recover the name of the tense
  * @method gtensename
  * @public
  * @memberof Morpho
  * @param  {String} tense the tense which we want to get the name (See {@link Morpho.Tense})
  * @return {String}       the name of the tense in the selected language
  */
  Me.gtensename = function(tense){
    switch (tense) {
      case Tense.Pa:
      return "past";
      case Tense.Pr:
      return "present";
      case Tense.Fu:
      return "future";
    }

    return "";
  };

  /**
   * Returns a list of verb types
   *
   * @method gverbtype
   * @public
   * @abstract
   * @memberof Morpho
   * @return {String[]}     list of verb types
   */
  Me.lvtype = function(){
    return [];
  };

  /**
   * Given a verb, it detects its type
   *
   * @method getVerbType
   * @public
   * @abstract
   * @memberof Morpho
   * @return {String}    verb's type
   */
  Me.gvtype = function(){
    return "";
  };

  /**
  * This function returns an object of available conjugation forms for the current language
  * @example
  * {
  *  "form_name": {opts}
  * }
  *
  * @method gform
  * @public
  * @memberof Morpho
  * @return {Object[]}  Array of conjugation forms available for the language
  */
  Me.gform = function(){
    //Past and Present are defaults
    return {
      "Indicative present": {
        mood: Mood.Ind,
        tense: Tense.Pr,
        aspect: Aspect.S
      },
      "Indicative past": {
        mood: Mood.Ind,
        tense: Tense.Pa,
        aspect: Aspect.S
      },
      "Indicative future": {
        mood: Mood.Ind,
        tense: Tense.Fu,
        aspect: Aspect.S
      }
    };
  };


  /**
  * Each language has a conjugation table model.
  * For example, in English, Arabic and French, we put pronouns in rows.
  * As for Japanese, the conjugation doesn't follow that pattern.
  * @method gconjmod
  * @public
  * @memberof Morpho
  * @return {Object}   conjugation model with rows and cols
  */
  Me.gconjmod = function(){
    //Past and Present are defaults
    return {
      rows: ["Pronoun"],
      cols: ["Voice", "Negation"]
    };
  };


  /**
   * Returns the available options for conjugation such as pronouns, negation, voice, etc.
   * @method lopt
   * @public
   * @memberof Morpho
   * @param  {String}    optLabel Can be: "Pronoun", "Negation", "Voice"
   * @return {Object[]}             A list of parameters related to optLabel and the processed language
   */
  Me.lopt = function(optLabel){
    switch (optLabel) {
      case "Pronoun": return this._gPpOpts();
      case "Negation": return this._gNegOpts();
      case "Voice": return this._gVoiceOpts();
      default: return [{}];
    }
  };

  /**
   * Returns the name of a conjugation parameter (Pronoun, Negation, Voice) given some options
   * @example
   *    var opts = {
   *      person: "first", // Morpho.Feature.Person.F
   *      number: "singular" // Morpho.Feature.Number.S
   *    };
   *    var I = getOptName("Pronoun", opts);
   * // In English, it will give: "I"
   * // In Arabic, it will give: "أنا"
   *
   * @method goptname
   * @public
   * @memberof Morpho
   * @param  {String}   optLabel can be: Pronoun, Negation, Voice
   * @param  {Object}   opts     The parameters
   * @return {String}            The label of this parameter in the current language
   */
  Me.goptname = function(optLabel, opts){
    switch (optLabel) {
      case "Pronoun": return this._gPpName(opts);
      case "Negation": return this._gNegName(opts);
      case "Voice": return this._gVoiceName(opts);
      default:

    }
    return "";
  };

  //==========================================
  // CONJUGATION OPTIONS PROTECTED FUNCTIONS
  //==========================================

  /**
   * Returns the list of negation options for verb conjugation
   *
   * @method _gNegOpts
   * @protected
   * @memberof Morpho
   * @return {Object[]}        The list of available negation options
   */
  Me._gNegOpts = function(){
    return [
        {negated:0}, //Positive
        {negated:1}//negative
    ];
  };

  /**
   * Returns the label of the negation in the current language
   *
   * @method _gNegName
   * @protected
   * @memberof Morpho
   * @param  {Object}        opts An object containing the attribute: negated: (0|1)
   * @return {String}             the label of the negation in the current language
   */
  Me._gNegName = function(opts){
    if (! opts) return "";
    if (opts.negated) return "negative";
    return "affirmative";
  };

  /**
   * Returns the list of conjugation voice for the current language
   *
   * @method _gVoiceOpts
   * @protected
   * @memberof Morpho
   * @return {Object[]}     A list of conjugation voice parameters for the current language
   */
  Me._gVoiceOpts = function(){
    return [
        {voice: Voice.A}, //Active voice
        {voice: Voice.P} //Passive voice
    ];
  };

  /**
   * Returns the conjugation voice's name in the current language
   *
   * @method _gVoiceName
   * @protected
   * @memberof Morpho
   * @param  {Object}     opts An object with one attribute: voice
   * @return {String}          the label of the voice in the current language
   */
  Me._gVoiceName = function(opts){
    if (! opts) return "";
    if (! opts.voice) return "";
    switch (opts.voice) {
      case Voice.A: return "active";
      case Voice.P: return "passive";
    }
    return "";
  };

  /**
   * Returns a list of options for pronouns in the current language
   *
   * @method _gPpOpts
   * @protected
   * @memberof Morpho
   * @return {Object[]}       List of pronouns options
   */
  Me._gPpOpts = function(){
    return [{}];
  };

  /**
  * Get the personal pronoun using options like: person, gender, etc.&lt;br>
  * for example, the parameters for the personal pronoun "I": &lt;br>
  * @example
  *    {
  *      person: Morpho.Feature.Person.F, // "first"
  *      number: Morpho.Feature.Number.S // "singular"
  *    }
  *
  * @method _gPpName
  * @protected
  * @memberof Morpho
  * @param  {Object} opts An object containing parameters: person, gender, number.
  * @return {String}      the pronoun
  */
  Me._gPpName = function(_opts){
    return "";
  };


  //==========================================
  // NORMALIZATION FUNCTIONS
  //==========================================

  /**
  * Normalization method, used to delete non used chars or to replace some with others, etc.
  *
  * @method norm
  * @public
  * @memberof Morpho
  * @param  {String} word the word to be normalized
  * @param  {String} opts some options (optional) where each language defines its own
  * normalization options
  * @return {String}      normalized word
  */
  Me.norm = function(word, _opts){
    return word;
  };


  //==========================================
  // SEGMENTATION FUNCTIONS
  //==========================================

  /**
   * Segment a given text
   * @param  {String} text the text to be segmennted into sentences
   * @return {String[]}      a list of sentences
   */
  Me.gsents = function (text) {
    return text.split(/[.?!]\s*/).filter(Boolean);
  }

  /**
   * Tokenize a given text (mostly, a sentence)
   * @param  {String} text the sentence to be tokenized
   * @return {String[]}      a list of words
   */
  Me.tokenize = function (text) {
    return text.split(/\s+/);
  }

  /**
   * Delete stop words from a list of words
   * @param  {String[]} words list of words
   * @return {String[]}       filtered list of words
   */
  Me.filter = function (words) {
    return words;
  }

  //==========================================
  // HELPER FUNCTIONS
  //==========================================

  /**
   * Given a morpho object for a certain language, and a branch (row or col);
   * This function returns an object containing its lables, spans and opts
   *
   * @method parseConjModelBranch
   * @private
   * @static
   * @memberof Morpho
   * @param  {Morpho}             morpho A Morpho object
   * @param  {Object}             branch Can be a row or a
   * @return {{labels: String[][], spans: Number[], opts: Object[]}} Presentation information about the branch
   */
  function parseConjModelBranch(morpho, branch){
    let result = {
      labels: [], // Array[Array[string]]: each level have many labels
      spans: [1], // spans of each level
      opts: [{}]
    };

    for (let bi = 0; bi &lt; branch.length; bi++){
      let tmpOpts = [];
      let opts = morpho.getOptLists(branch[bi]);
      for(let si = 0; si &lt; result.spans.length; si++){
        result.spans[si] *= opts.length;
      }
      let labels = [];
      result.opts.forEach(function(val, idx){
        opts.forEach(function(val2){
          let fuseOpts = Object.assign({}, val, val2);
          tmpOpts.push(fuseOpts);
          if(!idx){//we process labels just once
            labels.push(morpho.getOptName(branch[bi], val2));
          }
        });
      });

      result.opts = tmpOpts;
      result.spans.push(1);
      result.labels.push(labels);

    }
    result.spans.shift();

    return result;
  }

  /**
   * This method is a helper for presenting conjugation tables.
   * It takes a Morpho object of a certain language, then creates
   * rows labels and columns labels for this language
   *
   * @method parseConjModel
   * @public
   * @static
   * @memberof Morpho
   * @param  {Morpho}       morpho A Morpho object specified for a given language
   * @return {{rows: {labels: String[][], spans: Number[], opts: Object[]} ,
   * cols: {labels: String[][], spans: Number[], opts: Object[]} }}  - Information about columns and rows in conjugation
   */
  Morpho.parseConjModel = function(morpho) {

    let result = {
      rows: {},
      cols: {}
    };

    if (! (morpho instanceof Morpho)) return result;

    let model = morpho.getConjugModel();

    result.rows = parseConjModelBranch(morpho, model.rows);
    result.cols = parseConjModelBranch(morpho, model.cols);

    return result;

  };

  //==========================================
  // HELPER FUNCTIONS
  //==========================================

  /*
  * A debugging function which do nothing
  * @method dummyDebug
  * @private
  */
  function dummyDebug() {}

  /*
  * A debugging function which pushes the arguments to the consoles log
  * @method realDebug
  * @private
  */
  function realDebug() {
    console.log(Array.prototype.slice.call(arguments).join(" "));
  }

  //==========================================
  // LONG FUNCTIONS
  //==========================================

  /**
   * Segment a given text
   * @param  {String} text the text to be segmennted into sentences
   * @return {String[]}      a list of sentences
   */
  Me.splitToSentences = function (text) {
    return this.gsents(text);
  }

  /**
   * Delete stop words from a list of words
   * @param  {String[]} words list of words
   * @return {String[]}       filtered list of words
   */
  Me.filterStopWords = function (words) {
    return this.filter(words);
  }

  /**
  * Normalization method, used to delete non used chars or to replace some with others, etc.
  *
  * @method normalize
  * @public
  * @memberof Morpho
  * @param  {String} word the word to be normalized
  * @param  {String} opts some options (optional) where each language defines its own
  * normalization options
  * @return {String}      normalized word
  */
  Me.normalize = function(word, _opts){
    return this.norm(word, _opts);
  };

  /**
  * Returns the list of available stemming methods
  * @method availableStemmers
  * @public
  * @final
  * @memberof Morpho
  * @return {String[]}  Array of Strings containing stemmers names
  */
  Me.availableStemmers = function(){
    return this.lstem();
  };

/**
  * Sets the current stemmer
  *
  * @method setCurrentStemmer
  * @public
  * @final
  * @memberof Morpho
  * @param {String} StemmerName stemmer method's name
  */
  Me.setCurrentStemmer = function (StemmerName) {
    this.sstem(StemmerName);
  };

  Me.getStemmerDesc = function (stemmerName) {
    return this.gstemdesc(stemmerName);
  }

  /**
  * Convert a word: singular to plural; verb to noun; etc
  *
  * @method convertPoS
  * @public
  * @final
  * @memberof Morpho
  * @param  {String} word the word to be converted
  * @return {String}      converted word
  */
  Me.convertPoS = function(word){
    return this.conv(word);
  };

  /**
  * Returns the list of available converting methods
  * @method availablePosConverters
  * @public
  * @final
  * @memberof Morpho
  * @return {String[]}  Array of Strings containing converters names
  */
  Me.availablePosConverters = function(){
    return this.lconv();
  };

  /**
  * Sets the current PoS converter
  *
  * @method setCurrentPosConverter
  * @public
  * @final
  * @memberof Morpho
  * @param {String} converterName converter method's name
  */
  Me.setCurrentPosConverter = function (converterName) {
    this.sconv(converterName);
  };

  Me.getPosConverterDesc = function (converterName) {
    return this.gconvdesc(converterName);
  };

  /**
  * This function is used for verb conjugation
  *
  * @method conjugate
  * @public
  * @memberof Morpho
  * @param  {String} verb the word to be conjugated
  * @param  {Object} opts  options for tense, case, voice, aspect, person, number, gender, mood, and other
  * @return {String}      Conjugated verb
  */
  Me.conjugate = function(verb, _opts){
    return this.conj(verb, _opts);
  };

  /**
  * This method is used to recover the name of the tense
  * @method getTenseName
  * @public
  * @memberof Morpho
  * @param  {String} tense the tense which we want to get the name (See {@link Morpho.Tense})
  * @return {String}       the name of the tense in the selected language
  */
  Me.getTenseName = function(tense){
    return this.gtensename();
  };

  /**
  * Returns a list of verb types
  *
  * @method getVerbTypes
  * @public
  * @abstract
  * @memberof Morpho
  * @return {String[]}     list of verb types
  */
  Me.getVerbTypes = function(){
    return this.lvtype();
  };

  /**
  * Given a verb, it detects its type
  *
  * @method getVerbType
  * @public
  * @abstract
  * @memberof Morpho
  * @return {String}    verb's type
  */
  Me.getVerbType = function(){
    return this.gvtype();
  };

  /**
  * This function returns an object of available conjugation forms for the current language
  * @example
  * {
  *  "form_name": {opts}
  * }
  *
  * @method getForms
  * @public
  * @memberof Morpho
  * @return {Object[]}  Array of conjugation forms available for the language
  */
  Me.getForms = function(){
    return this.lform();
  };


  /**
  * Each language has a conjugation table model.
  * For example, in English, Arabic and French, we put pronouns in rows.
  * As for Japanese, the conjugation doesn't follow that pattern.
  * @method getConjugModel
  * @public
  * @memberof Morpho
  * @return {Object}   conjugation model with rows and cols
  */
  Me.getConjugModel = function(){
    return this.gconjmod();
  };


  /**
  * Returns the available options for conjugation such as pronouns, negation, voice, etc.
  * @method getOptLists
  * @public
  * @memberof Morpho
  * @param  {String}    optLabel Can be: "Pronoun", "Negation", "Voice"
  * @return {Object[]}             A list of parameters related to optLabel and the processed language
  */
  Me.getOptLists = function(optLabel){
    return this.lopt(optLabel);
  };

  /**
  * Returns the name of a conjugation parameter (Pronoun, Negation, Voice) given some options
  * @example
  *    var opts = {
  *      person: "first", // Morpho.Feature.Person.F
  *      number: "singular" // Morpho.Feature.Number.S
  *    };
  *    var I = getOptName("Pronoun", opts);
  * // In English, it will give: "I"
  * // In Arabic, it will give: "أنا"
  *
  * @method getOptName
  * @public
  * @memberof Morpho
  * @param  {String}   optLabel can be: Pronoun, Negation, Voice
  * @param  {Object}   opts     The parameters
  * @return {String}            The label of this parameter in the current language
  */
  Me.getOptName = function(optLabel, opts){
    return this.goptname(optLabel, opts);
  };

}());
</code></pre>
        </article>
    </section>




</div>

<footer>
    <img class="logo" src="logo.png" style="width: 50px; height: 50px">
    <div class="footer-text">NHN Entertainment. Frontend Development Lab</div>
</footer>
<script>prettyPrint();</script>
<script src="scripts/jquery.min.js"></script>
<script src="scripts/tui-doc.js"></script>
<script src="scripts/linenumber.js"></script>

    <script>
        var id = '_sub'.replace(/"/g, '_');
        var selectedApi = document.getElementById(id); // do not use jquery selector
        var $selectedApi = $(selectedApi);

        $selectedApi.removeClass('hidden');
        $selectedApi.parent().find('.glyphicon').removeClass('glyphicon-plus').addClass('glyphicon-minus');
        showLnbApi();
    </script>

</body>
</html>
